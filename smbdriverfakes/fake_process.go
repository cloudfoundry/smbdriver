// This file was generated by counterfeiter
package smbdriverfakes

import (
	"os"
	"sync"

	"github.com/tedsuo/ifrit"
)

type FakeProcess struct {
	ReadyStub        func() <-chan struct{}
	readyMutex       sync.RWMutex
	readyArgsForCall []struct{}
	readyReturns     struct {
		result1 <-chan struct{}
	}
	WaitStub        func() <-chan error
	waitMutex       sync.RWMutex
	waitArgsForCall []struct{}
	waitReturns     struct {
		result1 <-chan error
	}
	SignalStub        func(os.Signal)
	signalMutex       sync.RWMutex
	signalArgsForCall []struct {
		arg1 os.Signal
	}
}

func (fake *FakeProcess) Ready() <-chan struct{} {
	fake.readyMutex.Lock()
	fake.readyArgsForCall = append(fake.readyArgsForCall, struct{}{})
	fake.readyMutex.Unlock()
	if fake.ReadyStub != nil {
		return fake.ReadyStub()
	} else {
		return fake.readyReturns.result1
	}
}

func (fake *FakeProcess) ReadyCallCount() int {
	fake.readyMutex.RLock()
	defer fake.readyMutex.RUnlock()
	return len(fake.readyArgsForCall)
}

func (fake *FakeProcess) ReadyReturns(result1 <-chan struct{}) {
	fake.ReadyStub = nil
	fake.readyReturns = struct {
		result1 <-chan struct{}
	}{result1}
}

func (fake *FakeProcess) Wait() <-chan error {
	fake.waitMutex.Lock()
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct{}{})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub()
	} else {
		return fake.waitReturns.result1
	}
}

func (fake *FakeProcess) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeProcess) WaitReturns(result1 <-chan error) {
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 <-chan error
	}{result1}
}

func (fake *FakeProcess) Signal(arg1 os.Signal) {
	fake.signalMutex.Lock()
	fake.signalArgsForCall = append(fake.signalArgsForCall, struct {
		arg1 os.Signal
	}{arg1})
	fake.signalMutex.Unlock()
	if fake.SignalStub != nil {
		fake.SignalStub(arg1)
	}
}

func (fake *FakeProcess) SignalCallCount() int {
	fake.signalMutex.RLock()
	defer fake.signalMutex.RUnlock()
	return len(fake.signalArgsForCall)
}

func (fake *FakeProcess) SignalArgsForCall(i int) os.Signal {
	fake.signalMutex.RLock()
	defer fake.signalMutex.RUnlock()
	return fake.signalArgsForCall[i].arg1
}

var _ ifrit.Process = new(FakeProcess)
